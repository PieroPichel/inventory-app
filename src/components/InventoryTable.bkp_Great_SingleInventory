import { useEffect, useState } from "react";
import { databases, ID } from "../appwrite";
import { Query } from "appwrite";

const DB_ID = "697dcef40009d64e2fe1";
const COLLECTION_ID = "inventory_items";

export default function InventoryTable() {
  const [items, setItems] = useState([]);
  const [showAddModal, setShowAddModal] = useState(false);
  const [showEditModal, setShowEditModal] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");

  const [page, setPage] = useState(0);
  const PAGE_SIZE = 100;
  const [totalItems, setTotalItems] = useState(0);

  const emptyItem = {
    Item: "",
    stock_type: "",
    Category: "Food",
    subcategory: "",
    quantity: "",
    Min_Stock: "0",
    Unit: "",
    storage_location: "",
    expiry_date: "",
    life: "Short-Life",
  };

  const [newItem, setNewItem] = useState({ ...emptyItem });
  const [editItem, setEditItem] = useState(null);

  const CATEGORY_OPTIONS = [
    "Food",
    "Household_Essentials",
    "Personal_Care_&_Home_Care",
    "Pet_Supplies",
    "Baby_Supplies",
  ];

  const LIFE_OPTIONS = [
    "Short-Life",
    "Medium-Life",
    "Long-Life",
    "Non-Perishable",
  ];

  // Load items for current page
  const loadItems = () => {
    databases
      .listDocuments(DB_ID, COLLECTION_ID, [
        Query.limit(PAGE_SIZE),
        Query.offset(page * PAGE_SIZE),
      ])
      .then((res) => {
        setItems(res.documents);
        setTotalItems(res.total);
      })
      .catch((err) => console.error("Error loading items:", err));
  };

  useEffect(() => {
    loadItems();
  }, [page]);

  const formatDate = (dateString) => {
    if (!dateString) return "";
    const date = new Date(dateString);
    if (isNaN(date)) return dateString;
    return date.toLocaleDateString();
  };

  // --- ALERT LOGIC ---
  const today = new Date();
  const oneWeekFromNow = new Date();
  oneWeekFromNow.setDate(today.getDate() + 7);

  const getAlertStatus = (item) => {
    const quantity = Number(item["quantity"]);
    const minStock = Number(item["Min_Stock"] ?? 0);
    const expiry = item["expiry_date"] ? new Date(item["expiry_date"]) : null;

    if (!isNaN(quantity) && !isNaN(minStock) && quantity < minStock) return "low";
    if (expiry && expiry < today) return "expired";
    if (expiry && expiry >= today && expiry <= oneWeekFromNow) return "soon";
    return null;
  };

  const getAlertBadge = (item) => {
    const status = getAlertStatus(item);

    if (status === "expired") return <span style={{ color: "#ff6666" }}>Expired</span>;
    if (status === "soon") return <span style={{ color: "#ffcc66" }}>Expiring soon</span>;
    if (status === "low") return <span style={{ color: "#ffff66" }}>Low stock</span>;
    return null;
  };

  const sortedItems = [...items].sort((a, b) => {
    const aAlert = getAlertStatus(a) ? 1 : 0;
    const bAlert = getAlertStatus(b) ? 1 : 0;
    return bAlert - aAlert;
  });

  const getRowStyle = (item) => {
    const status = getAlertStatus(item);
    return {
      background: "#121212",
      color: "#eee",
      fontWeight: status ? "bold" : "normal",
    };
  };

  // --- DELETE ITEM ---
  const deleteItem = async (id) => {
    try {
      await databases.deleteDocument(DB_ID, COLLECTION_ID, id);
      loadItems();
    } catch (err) {
      console.error("Delete failed:", err);
      alert("Delete failed — check Appwrite permissions.");
    }
  };

  // --- VALIDATION ---
  const validateItem = (item) => {
    const {
      Item,
      stock_type,
      subcategory,
      quantity,
      Min_Stock,
      Unit,
      life,
    } = item;

    if (!Item.trim()) return "Item is required.";
    if (Item.length > 20) return "Item must be at most 20 characters.";

    if (stock_type && stock_type.length > 20)
      return "Stock type must be at most 20 characters.";

    if (!subcategory.trim()) return "Subcategory is required.";
    if (subcategory.length > 20)
      return "Subcategory must be at most 20 characters.";

    const q = parseFloat(quantity);
    if (isNaN(q)) return "Quantity must be a number.";
    if (q < 0) return "Quantity cannot be negative.";

    if (Min_Stock !== "" && Min_Stock !== null) {
      const m = parseFloat(Min_Stock);
      if (isNaN(m)) return "Min Stock must be a number.";
      if (m < 0) return "Min Stock cannot be negative.";
    }

    if (!Unit.trim()) return "Unit is required.";
    if (Unit.length > 10) return "Unit must be at most 10 characters.";

    if (!life.trim()) return "Life is required.";

    return null;
  };

  // --- ADD ITEM ---
  const addItem = async () => {
    const validationError = validateItem(newItem);
    if (validationError) {
      setErrorMessage(validationError);
      return;
    }

    setErrorMessage("");

    const payload = {
      ...newItem,
      quantity: parseFloat(newItem.quantity),
      Min_Stock: newItem.Min_Stock ? parseFloat(newItem.Min_Stock) : 0,
      expiry_date: newItem.expiry_date || null,
    };

    try {
      await databases.createDocument(DB_ID, COLLECTION_ID, ID.unique(), payload);

      setShowAddModal(false);
      setNewItem({ ...emptyItem });

      setPage(0);
      loadItems();
    } catch (err) {
      console.error("Add failed:", err);
      alert("Add failed — check Appwrite schema/permissions.");
    }
  };

  // --- OPEN EDIT MODAL ---
  const openEditModal = (item) => {
    setEditItem({
      ...item,
      expiry_date: item.expiry_date || "",
    });
    setShowEditModal(true);
    setErrorMessage("");
  };

  // --- SAVE EDIT ---
  const saveEdit = async () => {
    const validationError = validateItem(editItem);
    if (validationError) {
      setErrorMessage(validationError);
      return;
    }

    const payload = {
      ...editItem,
      quantity: parseFloat(editItem.quantity),
      Min_Stock: editItem.Min_Stock ? parseFloat(editItem.Min_Stock) : 0,
      expiry_date: editItem.expiry_date || null,
    };

    try {
      await databases.updateDocument(
        DB_ID,
        COLLECTION_ID,
        editItem.$id,
        payload
      );

      setShowEditModal(false);
      setEditItem(null);
      loadItems();
    } catch (err) {
      console.error("Edit failed:", err);
      alert("Edit failed — check Appwrite schema/permissions.");
    }
  };

  return (
    <div
      style={{
        padding: "20px",
        background: "#121212",
        minHeight: "100vh",
        color: "#eee",
      }}
    >
      <h2 style={{ marginBottom: "10px" }}>Household Inventory</h2>
      <h3 style={{ marginBottom: "20px", color: "#aaa" }}>
        Showing {items.length} of {totalItems} items (page {page + 1} of{" "}
        {Math.max(1, Math.ceil(totalItems / PAGE_SIZE))})
      </h3>

      <button
        onClick={() => setShowAddModal(true)}
        style={{
          padding: "10px 20px",
          marginBottom: "20px",
          background: "#333",
          color: "#fff",
          border: "1px solid #555",
          borderRadius: "6px",
          cursor: "pointer",
        }}
      >
        + Add Item
      </button>

      {/* ---------------------- ADD ITEM MODAL ---------------------- */}
      {showAddModal && (
        <Modal
          title="Add New Item"
          item={newItem}
          setItem={setNewItem}
          onSave={addItem}
          onCancel={() => {
            setShowAddModal(false);
            setErrorMessage("");
          }}
          errorMessage={errorMessage}
          CATEGORY_OPTIONS={CATEGORY_OPTIONS}
          LIFE_OPTIONS={LIFE_OPTIONS}
        />
      )}

      {/* ---------------------- EDIT ITEM MODAL ---------------------- */}
      {showEditModal && editItem && (
        <Modal
          title="Edit Item"
          item={editItem}
          setItem={setEditItem}
          onSave={saveEdit}
          onCancel={() => {
            setShowEditModal(false);
            setEditItem(null);
            setErrorMessage("");
          }}
          errorMessage={errorMessage}
          CATEGORY_OPTIONS={CATEGORY_OPTIONS}
          LIFE_OPTIONS={LIFE_OPTIONS}
        />
      )}

      {/* ---------------------- MAIN TABLE ---------------------- */}
      <table
        style={{
          width: "100%",
          borderCollapse: "collapse",
          border: "1px solid #444",
        }}
      >
        <thead>
          <tr>
            <th style={th}>Item</th>
            <th style={th}>Stock Type</th>
            <th style={th}>Category</th>
            <th style={th}>Subcategory</th>
            <th style={th}>Life</th>
            <th style={th}>Qty</th>
            <th style={th}>Min</th>
            <th style={th}>Unit</th>
            <th style={th}>Location</th>
            <th style={th}>Expiry</th>
            <th style={th}>Actions</th>
          </tr>
        </thead>

        <tbody>
          {sortedItems.map((item) => (
            <tr key={item.$id} style={getRowStyle(item)}>
              <td style={td}>
                {item["Item"]} {getAlertBadge(item)}
              </td>
              <td style={td}>{item["stock_type"]}</td>
              <td style={td}>{item["Category"]}</td>
              <td style={td}>{item["subcategory"]}</td>
              <td style={td}>{item["life"]}</td>
              <td style={td}>{item["quantity"]}</td>
              <td style={td}>{item["Min_Stock"]}</td>
              <td style={td}>{item["Unit"]}</td>
              <td style={td}>{item["storage_location"]}</td>
              <td style={td}>{formatDate(item["expiry_date"])}</td>

              <td style={td}>
                <button
                  onClick={() => openEditModal(item)}
                  style={{
                    background: "#444",
                    color: "#fff",
                    border: "none",
                    padding: "6px 10px",
                    borderRadius: "4px",
                    cursor: "pointer",
                    marginRight: "6px",
                  }}
                >
                  Edit
                </button>

                <button
                  onClick={() => deleteItem(item.$id)}
                  style={{
                    background: "#b30000",
                    color: "#fff",
                    border: "none",
                    padding: "6px 10px",
                    borderRadius: "4px",
                    cursor: "pointer",
                  }}
                >
                  Delete
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* ---------------------- PAGINATION ---------------------- */}
      <div
        style={{
          marginTop: "20px",
          display: "flex",
          gap: "10px",
          alignItems: "center",
        }}
      >
        <button
          onClick={() => setPage((p) => Math.max(0, p - 1))}
          disabled={page === 0}
          style={{
            padding: "8px 12px",
            background: page === 0 ? "#333" : "#444",
            color: "#fff",
            border: "1px solid #555",
            borderRadius: "4px",
            cursor: page === 0 ? "not-allowed" : "pointer",
          }}
        >
          Previous
        </button>

        <span style={{ color: "#ccc" }}>
          Page {page + 1} of {Math.max(1, Math.ceil(totalItems / PAGE_SIZE))}
        </span>

        <button
          onClick={() => setPage((p) => p + 1)}
          disabled={(page + 1) * PAGE_SIZE >= totalItems}
          style={{
            padding: "8px 12px",
            background:
              (page + 1) * PAGE_SIZE >= totalItems ? "#333" : "#444",
            color: "#fff",
            border: "1px solid #555",
            borderRadius: "4px",
            cursor:
              (page + 1) * PAGE_SIZE >= totalItems
                ? "not-allowed"
                : "pointer",
          }}
        >
          Next
        </button>
      </div>
    </div>
  );
}

/* ---------------------- MODAL COMPONENT ---------------------- */

function Modal({
  title,
  item,
  setItem,
  onSave,
  onCancel,
  errorMessage,
  CATEGORY_OPTIONS,
  LIFE_OPTIONS,
}) {
  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        background: "rgba(0,0,0,0.7)",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        zIndex: 1000,
      }}
    >
      <div
        style={{
          background: "#1e1e1e",
          padding: "20px",
          borderRadius: "8px",
          width: "90%",
          maxWidth: "400px",
        }}
      >
        <h3>{title}</h3>

        {errorMessage && (
          <div
            style={{
              background: "#4a0000",
              color: "#ffb3b3",
              padding: "8px",
              borderRadius: "4px",
              marginBottom: "10px",
              fontSize: "0.9rem",
            }}
          >
            {errorMessage}
          </div>
        )}

        <label>Item *</label>
        <input
          type="text"
          maxLength={20}
          value={item.Item}
          onChange={(e) => setItem({ ...item, Item: e.target.value })}
          style={inputStyle}
        />

        <label>Stock Type</label>
        <input
          type="text"
          maxLength={20}
          value={item.stock_type}
          onChange={(e) => setItem({ ...item, stock_type: e.target.value })}
          style={inputStyle}
        />

        <label>Category *</label>
        <select
          value={item.Category}
          onChange={(e) => setItem({ ...item, Category: e.target.value })}
          style={inputStyle}
        >
          {CATEGORY_OPTIONS.map((cat) => (
            <option key={cat} value={cat}>
              {cat}
            </option>
          ))}
        </select>

        <label>Subcategory *</label>
        <input
          type="text"
          maxLength={20}
          value={item.subcategory}
          onChange={(e) => setItem({ ...item, subcategory: e.target.value })}
          style={inputStyle}
        />

        <label>Life *</label>
        <select
          value={item.life}
          onChange={(e) => setItem({ ...item, life: e.target.value })}
          style={inputStyle}
        >
          {LIFE_OPTIONS.map((life) => (
            <option key={life} value={life}>
              {life}
            </option>
          ))}
        </select>

        <label>Quantity *</label>
        <input
          type="number"
          min="0"
          step="0.01"
          value={item.quantity}
          onChange={(e) => setItem({ ...item, quantity: e.target.value })}
          style={inputStyle}
        />

        <label>Min Stock</label>
        <input
          type="number"
          min="0"
          step="0.01"
          value={item.Min_Stock}
          onChange={(e) => setItem({ ...item, Min_Stock: e.target.value })}
          style={inputStyle}
          placeholder="0"
        />

        <label>Unit *</label>
        <input
          type="text"
          maxLength={10}
          value={item.Unit}
          onChange={(e) => setItem({ ...item, Unit: e.target.value })}
          style={inputStyle}
        />

        <label>Storage Location</label>
        <input
          type="text"
          value={item.storage_location}
          onChange={(e) =>
            setItem({ ...item, storage_location: e.target.value })
          }
          style={inputStyle}
        />

        <label>Expiry Date</label>
        <input
          type="date"
          value={item.expiry_date || ""}
          onChange={(e) =>
            setItem({ ...item, expiry_date: e.target.value })
          }
          style={inputStyle}
        />

        <button onClick={onSave} style={saveButtonStyle}>
          Save
        </button>

        <button
          onClick={onCancel}
          style={cancelButtonStyle}
        >
          Cancel
        </button>
      </div>
    </div>
  );
}

/* ---------------------- SHARED STYLES ---------------------- */

const inputStyle = {
  width: "100%",
  padding: "8px",
  background: "#333",
  color: "#fff",
  border: "1px solid #555",
  borderRadius: "4px",
  marginBottom: "10px",
};

const saveButtonStyle = {
  padding: "10px",
  width: "100%",
  background: "#4caf50",
  border: "none",
  color: "#fff",
  borderRadius: "6px",
  cursor: "pointer",
  marginTop: "10px",
};

const cancelButtonStyle = {
  padding: "10px",
  width: "100%",
  background: "#444",
  border: "none",
  color: "#fff",
  borderRadius: "6px",
  cursor: "pointer",
  marginTop: "10px",
};

const th = {
  border: "1px solid #444",
  padding: "8px",
  background: "#222",
  color: "#ccc",
  textAlign: "left",
};

const td = {
  border: "1px solid #333",
  padding: "8px",
};
